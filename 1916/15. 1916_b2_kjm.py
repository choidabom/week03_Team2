# https://m.blog.naver.com/ndb796/221234424646
import queue
import sys
import heapq

input=sys.stdin.readline
INF = int(1e9)  #e??이게 뭐지?

#graph= [[], [(2, 2), (3, 3), (1, 4), (10, 5)], [(2, 4)], [(1, 4), (1, 5)], [(3, 5)], []]
def dijkstra(start, end):
  queue= [] #주머니를 만드네?bfs 원리가 적용되나?
  
  
  heapq.heappush(queue, (0, start)) #밑에 while문 돌려면 que에 뭐가 있어야하니 마중물 격으로 1일 때 cost와 시작점(1)넣어줌
  # 갑자기 heap이 등장해서 여기서 1차 맨붕임. 
  # 와... 가치있는걸 꺼내려고 heap이 등장하는거구나..................................................................................
  # 왜 그냥 stack이나 que같은 주머니 만들어서 순서대로 꺼내면 되는데? 굳이 heap이라는 생소한 걸 쓰냐?
  # 주머니에 담은게 다 똑같은걸 담았으면 걍 순서대로 꺼내면 되는데 다른걸 담은거야..
  # 그럼 어떤 건 중요하고 어떤건 덜 중요할 거 아니냐. 힙을 쓰면(heappop) 알아서 가치있는 걸 먼저 꺼내준다고 
  # 왜? 힙은 최소, 최대 순으로 정렬을 시킨단 말이다. 여기서 최소랑 최대가 가치 인거임..
  # 그래서 갑분 힙이 등장하는거다. 스텍이나 큐가 등장하는게 아니고..(물론, 정렬한 다음에 스택과 큐에 넣어도 되긴 함.)

  distance[start] = 0 #현재 모든 disctance는 무한으로 설정 되어있는데 1자기 자신까지 가는 데 걸리는 시간은 0이니까 0으로 바꿔줨 
  while queue:
    dist, now= heapq.heappop(queue) 
    #지금 가방에 들어있는 것 중에 젤 중요한 것(비용을 최저로하는 것)을 꺼낸거임. 
    #초반에는 물론 하나밖에 안들어 있긴하지만.. 한싸이클 돌면 [(1,4), (2,2), (3,3),(10,5)] 이렇게 담김. 근데 잘봐 힙이니까 cost가 1인 1,4가 젤 앞에 담기잖아.

    if distance[now] < dist: 
      #이 코드는 왜 있는거냐면, 힙에서 꺼낸게(dist) 가치있는거(비용이 낮은)라며, 근데 내가 방금 꺼낸 것 보다 더 빨리가는 법을 알고 있는거지
      #뭐야 기껏 꺼냈는데 내가 현재 알고 있는 방법보다 오래걸리네? 쓸모 없는 정보네 한 상황임. 
      continue

    #그럼 아래서부터는 뭐야? 내가 알고있는 방법보다 더 가치 있는(=비용이 낮은) 정보를 heap으로 꺼낸 상황인거지. (=dist에 가치있는게 있는 상황임.) 물론 최초 dist는 0이라 이것보다 가치있는건 없긴 하지..
    #다른말로 dist가 현재 내가 알고있는 graph[now]를 가는 가장 좋은 방법임.
    
    # 우리 목적은 1만 보고 끝내는게 아니라 1에서 다른 장소로 간다했을 때 각 노드들의 최소 비용이 얼마인지 알고 싶은거니 다른놈들도 탐색을 해야함. (BFS/DFS등장)
    # 근데 한놈만 패다가 실패하면 쪽박차니까 골고루 때리기 시작(BFS)
    for next in graph[now]:  #graph[1] = [(2, 2), (3, 3), (1, 4), (10, 5)] #1과 연결된 놈들 골고루 때리기 시작 (참고로 2,2에서 앞에오는 숫자가 cost임)
      cost= dist+next[0] 
      #graph[now]까지 오는 방법중 내가 알고 있는 최적의 값(dist)에다가 다음 장소까지 가는데 드는 비용(next[1])을 더하면? 그 장소까지 다이렉트로 연결했을 때의 비용이 나옴.
      #단 cost는 다이렉트로 갔을 때의 최선의 비용일 뿐, 어디를 거쳐서 가면 더 빠른 경우는 고려하지 않은 상태임(지금 단계에서는 참고만해)

      if cost < distance[next[1]]:
        # 여기 되게 중요한 코드인데. 현재 cost에는 2까지 가는 가장 빠른 방법이 들어가있음(물론 가장 빠른게 아닐 수 있지만.. 현 상황에서는..).
        # 그 cost가 2번 노드 기록지에 적힌 숫자보다 작으면? 
        # 오 개이득인 상황임!
        distance[next[1]] = cost #2번 노드의 기록지를 더 좋은 숫자로 갈아 치운다.
        heapq.heappush(queue, (cost, next[1]))  #그리고 다른 놈들도 봐야하기 때문에 일단 가방에다가 2번 노드까지 가는데 최선의 방법을 적어서 넣는다. 
  return distance[end]
  

if __name__ == "__main__": #왜 이걸쓰지?
  N = int(input()) #도시의 개수
  M = int(input()) #버스의 개수
  
  graph= [[] for _ in range(N+1)]
  distance = [INF] * (N+1) 
  # 갑자기 distance라는 빈 배열을 여러개 만들고 거기에 숫자를 엄청 큰 숫자를 채워넣는 이유가 뭐냐?? 
  # 이걸 만들수밖에 없는 상황인 이유를 이해하지 못하면 외워서 풀지 않는 이상 문제를 해결 할 수 없겠지?
  # (이거 빈배열 만들고 False채워넣은거랑 비슷한 용도인데, false채워넣은건 노드별로 방문 여부를 체킹하려고 만든 출석체킹용 용지였고) 
  
  # 결론부터 말하면 비교하려고.(1이 다른 곳까지 가는 시간을 기록하려고)
  # distance는 기록지라고 생각하면 됨. (기록지는 이전의 나의 기록과 지금의 나의 기록을 비교하려고 만드는거지?)
  # 마찬가지로 기록지에 일단 더 나빠질 수 없는 최악의 숫자를 넣어놓고 (비용을 최소화해야하는 상황에서 최악은 무한이겠지?) 
  # 각 노드별로 최솟값을 구하면 그 기록지에 있는 숫자와 비교해서 더 작은걸로 갈아치우려고 만드는 것.

  for _ in range(M):
    start, end, cost = map(int, input().split())
    graph[start].append((cost, end)) #cost를 먼저 받았네? cost기준으로 정렬하려고
  # print(graph)
  starting, destination = map(int, input().split())

  print(dijkstra(starting,destination))